<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树最小深度</title>
    <url>/2021/09/15/leetcode-148/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。<br>Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>首先要了解二叉树，是指树的每个节点最多只能有<strong>两个</strong>子节点，在二叉树中分别成为“左子节点”和“右子节点”。因此二叉树的每一层最多含有$2^{n-1}$个节点，$n$为节点所在层数。<br>本题为给定二叉树，求二叉树的最小深度，有两种解题思路：</p>
<ol>
<li><strong>递归</strong>，如下图所示二叉树，其最小深度可以理解为左子树和右子树中的最小的深度加1，而左右子树又可以分为新的左右子树从而计算左右子树的最小深度，直到节点为null。<br><img src="/2021/09/15/leetcode-148/binary_tree.png" alt="二叉树示例"></li>
<li><strong>遍历</strong>，树的深度为根节点到叶子节点的距离，利用遍历的方法寻找叶子节点，从所有的叶子节点中找出距离根节点最近的那个，即找到最小深度。树的遍历一般分为前、中、后序遍历和层序遍历，在本题中最好选用层序遍历。</li>
</ol>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//递归结束条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = run(root.left);  <span class="comment">//计算左子树深度</span></span><br><span class="line">        <span class="keyword">int</span> right = run(root.right); <span class="comment">//计算右子树深度</span></span><br><span class="line">        <span class="keyword">if</span>(left*right != <span class="number">0</span>)&#123;  <span class="comment">// 若左右子树均有节点</span></span><br><span class="line">            <span class="keyword">return</span> (left&gt;right?right:left)+<span class="number">1</span>; <span class="comment">//取最小的深度加1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//若左子树或右子树没有节点</span></span><br><span class="line">            <span class="keyword">return</span> (left&gt;right?left:right)+<span class="number">1</span>; <span class="comment">//该子树深度为存在节点的那一边的深度加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归解法代码比较简答，需要注意的是递归结束条件为节点为null，还需要判断左子树或右子树无节点的情况。时间复杂度为$O(n)$，$n$为节点数（还不太懂，还要继续学习）。</p>
<h3 id="遍历解法"><a href="#遍历解法" class="headerlink" title="遍历解法"></a>遍历解法</h3><p>首先记录二叉树的各种遍历方法：</p>
<ol>
<li><strong>前序遍历</strong><br>递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">		preOrderTraverse(root.left);</span><br><span class="line">		preOrderTraverse(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
非递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	s.push(root);</span><br><span class="line">	<span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">		TreeNode t = s.pop();</span><br><span class="line">		<span class="keyword">while</span>(t != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(t.val);</span><br><span class="line">			<span class="keyword">if</span>(t.right != <span class="keyword">null</span>)	s.push(t.right);</span><br><span class="line">			t = t.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>中序遍历</strong><br>递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		midOrderTraverse(root.left);</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">		midOrderTraverse(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
非递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span>(root!=<span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			s.push(root);</span><br><span class="line">			root = root.left;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			root = s.pop();</span><br><span class="line">			System.out.println(root.val);</span><br><span class="line">			root = root.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>后序遍历</strong><br>递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		postOrderTraverse(root.left);</span><br><span class="line">		postOrderTraverse(root.right);</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
非递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; tag = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span>(root!=<span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			s.push(root);</span><br><span class="line">			tag.push(<span class="number">0</span>);</span><br><span class="line">			root = root.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!s.isEmpty() &amp;&amp; tag.peek()==<span class="number">1</span>)&#123;</span><br><span class="line">			tag.pop();</span><br><span class="line">			System.out.println(s.pop().val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!s.isEmpty() &amp;&amp; tag.peek()==<span class="number">0</span>)&#123;</span><br><span class="line">			tag.pop();</span><br><span class="line">			tag.push(<span class="number">1</span>);</span><br><span class="line">			root = s.peek().right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>层序遍历</strong><br>非递归实现代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		TreeNode t = q.poll();</span><br><span class="line">		System.out.println(t.val);</span><br><span class="line">		<span class="keyword">if</span>(t.left!=<span class="keyword">null</span>) q.offer(t.left);</span><br><span class="line">		<span class="keyword">if</span>(t.right!=<span class="keyword">null</span>) q.offer(t.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
利用层序遍历求二叉树的最小深度：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode t = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left==<span class="keyword">null</span> &amp;&amp; t.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
算法时间复杂度为$O(n)$.<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>这道题涉及二叉树的相关知识，学习到了二叉树的遍历方法（递归与非递归），也了解了有关递归解题的方法，需要坚持把148题总结完！！！有关算法复杂度的计算也要继续学习。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令总结</title>
    <url>/2021/09/15/linux/</url>
    <content><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="ls-———-展示所有指定目录下所有文件或文件夹"><a href="#ls-———-展示所有指定目录下所有文件或文件夹" class="headerlink" title="ls  ——— 展示所有指定目录下所有文件或文件夹"></a>ls  ——— 展示所有指定目录下所有文件或文件夹</h2><ul>
<li>-a  展示所有</li>
<li>-l   按长模式展示</li>
<li>-t   按时间顺序排序</li>
<li>-r   倒序</li>
<li>-h  与-l配合使用，适合人类阅读</li>
<li>-S  按大小排序</li>
</ul>
<h2 id="cd-———-切换目录"><a href="#cd-———-切换目录" class="headerlink" title="cd ——— 切换目录"></a>cd ——— 切换目录</h2><h2 id="pwd-———-当前目录路径"><a href="#pwd-———-当前目录路径" class="headerlink" title="pwd ——— 当前目录路径"></a>pwd ——— 当前目录路径</h2><h2 id="less-———-查看某个文本文件内容"><a href="#less-———-查看某个文本文件内容" class="headerlink" title="less ——— 查看某个文本文件内容"></a>less ——— 查看某个文本文件内容</h2><ul>
<li>Page Up或 b  向上一页</li>
<li>Page Down或空格  向下一页</li>
<li>up arrow 向上一行</li>
<li>down arrow 向下一行</li>
<li>/字符  向前查找某字符</li>
<li>n 查找上面指定的下一个字符</li>
<li>h 显示帮助屏幕</li>
<li>q 推出</li>
<li>G 移动到最后一行</li>
<li>g 移动到第一行</li>
</ul>
<p><img src="/2021/09/15/linux/Untitled.png" alt="Linux%E5%91%BD%E4%BB%A4%207f7dde58bce74b60a400633056adc75e/Untitled.png"></p>
<p><img src="/2021/09/15/linux/Untitled1.png" alt="Linux%E5%91%BD%E4%BB%A4%207f7dde58bce74b60a400633056adc75e/Untitled%201.png"></p>
<p><img src="/2021/09/15/linux/Untitled2.png" alt="Linux%E5%91%BD%E4%BB%A4%207f7dde58bce74b60a400633056adc75e/Untitled%202.png"></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul>
<li><ul>
<li>匹配任意个字符（0～无穷）</li>
</ul>
</li>
<li>?  匹配任意一个字符</li>
<li>[字符]  匹配任意一个中括号内字符</li>
<li>[!字符]  匹配任意一个非中括号内字符</li>
<li>[[:class:]]  匹配任意一个指定字符类的字符<ul>
<li>[:alnum:]  任意一个字母或数字</li>
<li>[:alpha:]  任意一个字母</li>
<li>[:digit:]  任意一个数字</li>
<li>[:lower:]  任意一个小写字母</li>
<li>[:upper:]  任意一个大写字母</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>WeakHashMap是什么？</title>
    <url>/2021/09/15/WeakHashMap/</url>
    <content><![CDATA[<h1 id="WeakHashMap是什么？"><a href="#WeakHashMap是什么？" class="headerlink" title="WeakHashMap是什么？"></a>WeakHashMap是什么？</h1><h1 id="1-四大引用"><a href="#1-四大引用" class="headerlink" title="1. 四大引用"></a>1. 四大引用</h1><p>在介绍WeakHashMap之前，必须先清楚Weak代表了什么？在java中，有四种对象的引用方式，俗称“强软弱虚”，分别对应强引用、软引用、弱引用和虚引用，这四种引用有不同的使用场景，理解它们是理解WeakHashMap的前提，四种引用的解释与使用场景如下表格所示：</p>
<style>
    table th:nth-of-type(1){
    width: 20%;
    }
    table th:nth-of-type(2){
    width: 40%
    ;
    }
    table th:nth-of-type(3){
    width: 40%;
    }
</style>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">引用名</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">最普通的引用，只要对象的强引用一直存在，该对象就永远不会被JVM垃圾回收</td>
<td style="text-align:center">只要不是特殊场景，都应该使用强引用</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">存在内存不足时，软引用的对象会被垃圾回收</td>
<td style="text-align:center">适合做缓存，当内存足够可以拿到缓存，内存紧张时，直接回收</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">无论内存足够与否，只要发生GC，就会被回收</td>
<td style="text-align:center">ThreadLocal、WeakHashMap</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">发生GC时，会回收虚引用对象，并且将回收通知记录在ReferenceQueue中</td>
<td style="text-align:center">在NIO中，虚引用可以用来管理堆外内存</td>
</tr>
</tbody>
</table>
</div>
<p>除了强引用外，其他三种引用方法的创建方法如下，</p>
<ul>
<li>软引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;T&gt; softTObject = <span class="keyword">new</span> SoftReference&lt;T&gt;(<span class="keyword">new</span> T());</span><br></pre></td></tr></table></figure>
<ul>
<li>弱引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;T&gt; weakTObject = <span class="keyword">new</span> WeakReference&lt;T&gt;(<span class="keyword">new</span> T());</span><br></pre></td></tr></table></figure>
<ul>
<li>虚引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;T&gt; phantomTObject = <span class="keyword">new</span> PhantomReference&lt;T&gt;(<span class="keyword">new</span> T(), queue);</span><br></pre></td></tr></table></figure>
<p>特别注意创建虚引用时需要加一个ReferenceQueue对象</p>
<p>这里只是简单介绍四大引用，会在以后另起一篇文章详细介绍四大引用的原理和使用。</p>
<h1 id="2-WeakHashMap"><a href="#2-WeakHashMap" class="headerlink" title="2. WeakHashMap"></a>2. WeakHashMap</h1><p>了解了四大引用后，再看WeakHashMap就会比较简单了，其实WeakHashMap就是加了弱引用的HashMap，其用法与HashMap几乎相同，唯一的区别就是：<strong>Map的key是通过弱引用建立的。</strong>虽然value没有使用弱引用，但是当key被回收时，value也会同时被清除。直接看源码中的解释：</p>
<blockquote>
<p>Hash table based implementation of the Map interface, with weak keys. An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector, that is, made finalizable, finalized, and then reclaimed. When a key has been discarded its entry is effectively removed from the map, so this class behaves somewhat differently from other Map implementations.<br>Both null values and the null key are supported. This class has performance characteristics similar to those of the HashMap class, and has the same efficiency parameters of initial capacity and load factor.<br>Like most collection classes, this class is not synchronized. A synchronized WeakHashMap may be constructed using the Collections.synchronizedMap method.</p>
</blockquote>
<p>总结下来有以下几点：</p>
<ul>
<li>实现了Map接口，有弱引用的key</li>
<li>entry将被回收清除当key不被正常使用</li>
<li>支持null值key和null值value</li>
<li>线程不安全，想要线程安全时要使用Collections.synchronizedMap</li>
</ul>
<p>核心代码，源码中大部分与HashMap实现相同，不同点在于Entry对象的构造上，Entry<K, v>对象继承了WeakReference类并实现了Map.Entry接口，如下所示。</K,></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(Object key, V value,</span><br><span class="line">              ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">              <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(key, queue);</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当key被GC时，就会被放入ReferenceQueue中，每次get时根据ReferenceQueue中的值删除对应的value，从而实现对key和value的自动回收。删除的具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">                Entry&lt;K,V&gt; p = prev;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (prev == e)</span><br><span class="line">                            table[i] = next;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            prev.next = next;</span><br><span class="line">                        <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                        <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在put方法中，可以看出当发生哈希冲突时，WeakHashMap使用的是拉链法解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Object k = maskNull(key);</span><br><span class="line">        <span class="keyword">int</span> h = hash(k);</span><br><span class="line">        Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">        <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">            resize(tab.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h1><p>实际中，WeakHashMap主要会用作缓存，在这篇<a href="https://blog.csdn.net/kaka0509/article/details/73459419">文章</a>中提到，tomcat中使用WeakHashMap做eden和longterm的分代缓存。</p>
<h1 id="4-实际使用"><a href="#4-实际使用" class="headerlink" title="4. 实际使用"></a>4. 实际使用</h1><p>如下代码执行后，结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;Object ,String&gt; hashMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line">        Object c = <span class="keyword">new</span> Object();</span><br><span class="line">        hashMap.put(a, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        hashMap.put(b, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        hashMap.put(c, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a != null 时：map size = &quot;</span> + hashMap.size());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;gc后：map size = &quot;</span> + hashMap.size());</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = null 时：map size = &quot;</span> + hashMap.size());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;gc后：map size = &quot;</span> + hashMap.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/15/WeakHashMap/Untitled.png" alt="HashMap"></p>
<p>换成HashMap后结果如下：</p>
<p><img src="/2021/09/15/WeakHashMap/Untitled1.png" alt="WeakHashMap"></p>
<p>可以看到WeakHashMap与HashMap的区别</p>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>链表排序</title>
    <url>/2021/09/15/leetcode-148-2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Sort a linked list in $O(n log n)$ time using constant space complexity.<br>以$O(nlogn)$的时间复杂度和常量级别的空间复杂度对链表进行排序。</p>
<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>题目为排序问题，排序算法大体可以分为两种：比较排序和非比较排序，其中比较排序的时间复杂度最小不会低于$O(nlogn)$，非比较排序的空间复杂度一般为$O(n)$，时间复杂度可以降低到$O(n)$，所以根据题目我们可以确定这个题目要用到的是比较排序。比较排序主要有：插入排序、归并排序、堆排序、快速排序等等，下面总结四种常见的比较排序算法的代码实现，均以数组为例。</p>
<ol>
<li>插入排序<br>插入排序就像玩扑克牌时整理牌一样，从数组的第2位(索引为1)开始，向前寻找该数字应该在的位置，直到最后一个数字，插入排序的时间复杂度为$O(n^2)$。计算方法是1+…+(n-1)的结果。（自己理解，具体的还得多记） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;key)&#123;</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>归并排序<br>归并排序的思想是将数组不断分裂，直到数组只剩2个或1个元素，然后再合并，利用了递归的理念。归并排序时间复杂度的递归式为$O(n)=2O(n/2)+T(n)+D(n)$该递归式的结果为$O(nlogn)$，即时间复杂度为$O(nlogn)$。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s&lt;e)&#123;</span><br><span class="line">           <span class="keyword">int</span> q = (e-s)/<span class="number">2</span> + s;</span><br><span class="line">           mergeSort(A, s, q);</span><br><span class="line">           mergeSort(A, q+<span class="number">1</span>, e);</span><br><span class="line">           Merge(A, s, q, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> s, <span class="keyword">int</span> q, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> lLength = q - s + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> rLength = e - q;</span><br><span class="line">       <span class="keyword">int</span>[] l = <span class="keyword">new</span> <span class="keyword">int</span>[lLength+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[rLength+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lLength;i++)&#123;</span><br><span class="line">           l[i] = A[s+i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rLength;j++)&#123;</span><br><span class="line">           r[j] = A[q+j+<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       l[lLength] = Integer.MAX_VALUE;</span><br><span class="line">       r[rLength] = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=s;k&lt;=e;k++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(l[i]&lt;r[j])&#123;</span><br><span class="line">               A[k] = l[i];</span><br><span class="line">               i += <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               A[k] = r[j];</span><br><span class="line">               j += <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>堆排序<br>堆排序的思想是通过建立最大堆或最小堆来实现排序，最大堆或最小堆是一种特殊的二叉树，这种二叉树的特点是所有父节点一定大于或小于其所有孩子节点。堆排序的操作顺序为建堆—&gt;输出根节点—&gt;维护最大堆。通过这样的循环操作就可以将数组排序。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = leftChild(i)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = rightChild(i)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        largest = getLargest(A, size, l, largest);</span><br><span class="line">        largest = getLargest(A, size, r, largest);</span><br><span class="line">        <span class="keyword">if</span>(largest!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = A[largest-<span class="number">1</span>];</span><br><span class="line">            A[largest-<span class="number">1</span>] = A[i-<span class="number">1</span>];</span><br><span class="line">            A[i-<span class="number">1</span>] = tmp;</span><br><span class="line">            maxHeap(A, largest, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLargest</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> size, <span class="keyword">int</span> l, <span class="keyword">int</span> largest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=size &amp;&amp; A[l]&gt;A[largest-<span class="number">1</span>])&#123;</span><br><span class="line">            largest = l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            maxHeap(A, i, A.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = A.length-<span class="number">1</span>;</span><br><span class="line">        buildMaxHeap(A);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = A[<span class="number">0</span>];</span><br><span class="line">            A[<span class="number">0</span>] = A[size];</span><br><span class="line">            A[size] = tmp;</span><br><span class="line">            size -= <span class="number">1</span>;</span><br><span class="line">            maxHeap(A, <span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>快速排序<br>快速排序可以说是比较排序算法中时间复杂度最低的算法，相比堆排序，其时间复杂度中的系数更小。快排的思想是通过递归的方式不断找到数组中元素应该在的位置，最核心的算法就是partition方法。快排的时间复杂度为$O(nlogn)$。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;e)&#123;</span><br><span class="line">            <span class="keyword">int</span> q = Partition(A, s, e);</span><br><span class="line">            quickSort(A, s, q-<span class="number">1</span>);</span><br><span class="line">            quickSort(A, q+<span class="number">1</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = A[e];</span><br><span class="line">        <span class="keyword">int</span> i = s-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&lt;e;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;x)&#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[e] = A[i+<span class="number">1</span>];</span><br><span class="line">        A[i+<span class="number">1</span>] = x;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1>本题只是将链表换为数组而已，故可以只需将排序算法稍微改变即可，思想是不变的，解题选用归并排序（因为看了评论很多人都选择了归并），与数组不同，需要通过循环找到链表的中间元素并将链表二分。代码为：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode half = getMidNode(head);</span><br><span class="line">        ListNode l1 = half.next;</span><br><span class="line">        half.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Merge(sortList(head), sortList(l1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">Merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode l = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = l;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">                l.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            l.next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            l.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getMidNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode half = head;</span><br><span class="line">        <span class="keyword">while</span>(head.next!=<span class="keyword">null</span> &amp;&amp; head.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            half = half.next;</span><br><span class="line">            head = head.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
希望自己以后能补充上其他排序的链表实现。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>本题涉及的就是最传统的排序算法，让我对排序算法进行了总结。除此以为，通过查看java源码，发现java在Array.sort()中使用的是TimSort排序算法，似乎在JDK7以前使用的归并排序，TimSort是2002年在Python上提出的算法，该算法结合了归并排序和插入排序，规定当数组长度小于64时使用插入，大于时使用归并，并且再归并时是将数组分成一个个run，而不是一个个元素，每个run都是原来就是升序或降序的，这样排序的效率更高。并且TimSort算法也很稳定。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>movie_loveLikeFlower</title>
    <url>/2021/09/15/movie-loveLikeFlower/</url>
    <content><![CDATA[<h1 id="“在末班车到来之前，一定要向她表白”"><a href="#“在末班车到来之前，一定要向她表白”" class="headerlink" title="“在末班车到来之前，一定要向她表白”"></a>“在末班车到来之前，一定要向她表白”</h1><p><span style="color:grey">前言</span></p>
<blockquote>
<p><em>终于重新开始写文章了，时间好像过去快一年了，期间发生了许多事情，我可以明确感受到自己每天像飘在天上一样，即使读书、逛咖啡店、认识新朋友甚至喝酒，也无法让我体验到所谓“内心到平静”。于是，在某天再次读完《人间失格》后，我决定重新记录自己到感想，每一次读书、看电影，或是内心异常波动时，都把自己的情绪写下来，以防止这些思绪像风一样抓不住，可惜我就是这样一个人，这篇文章是在产生这种想法后的二个月后，即便如此，我还是开始了，即便还有看起来更重要的事情，我还是希望赶快动笔，把自己想说的留在看似真实的世界中，这样我就不会总想找人诉说了。</em><br><em>老实说，我从来没写过什么随笔，别说随笔，从小到大，即使是读后感，我也会写的一踏糊涂，日记也会直接写成流水账，“没有重点”、“乏味无聊”，这是我对自己文字深刻的认识。然而今天，在偶然间看到这部电影后，我心底好像总有什么要涌出来一样，搞的我什么也做不好。也许是因为电影情节让我感同深受，也许是演员演技让我震撼，总之我必须写点什么了，这样恐怕才能睡着觉吧！</em><br><em>以上。</em></p>
<p>“开始，是结束的开始”</p>
</blockquote>
<p>可以说这句话是整部电影的核心思想，电影围绕着这句话讲述了一对年轻男女从恋爱到分手的故事，坂田浩二细腻真实的剧本以及菅田将晖和有村架纯精湛的演技，把爱情演绎的既美好又现实，我愿称之为日本版围城。电影从名字《花束般的恋爱》就告诉观众这注定不是美好的结局，男女主的爱情的确像花一样鲜艳、动人，也像花一样最终凋谢。</p>
<p>有人说电影可以又名“百分百合拍的男女无法恋爱”，也有人说电影中存在太多巧合，显得不是很真实，的确，男女主在电影的35分钟之前表现出无限的默契，从书籍、电影、穿衣还有穿插正常的笑脸帆布鞋（严重怀疑是广告！），就在我在屏幕前姨母笑了整整35分钟后，男主向女主表白了，在表白的这一天，男主早就计划好要在当天末班车到来之前向女主表白，最后一刻，店员如神助攻一般上错的一份巧克力芭菲，彷佛老天在跟男主说：“你今天还有话没有说哦”，于是，顺理成章，男女主在一起了，结束随即开始……</p>
<p><img src="/2021/09/15/movie-loveLikeFlower/640.jpg" alt="1"></p>
<p>随着几次小到不能再小的事情，男女主之间的裂痕越来越大，男女主的聚会也接近尾声了。在这场聚会的最后，没有人是错误的，女主的坚持自我，男主的承担责任，电影再一次向我们展现了，爱情中没有对错，这应该就是现实中爱情的缩影，没有狗血的故事，没有大是大非，只有渐渐的疏远，渐渐的离别，甚至在要提出分手时，男女主也再一次展现了他们的默契。即使这么合拍的两个人，最后还是分开了……</p>
<p><img src="/2021/09/15/movie-loveLikeFlower/6401.jpg" alt="2"></p>
<p>电影最后餐厅分手的情节可谓全篇的高潮，男女主的表演淋漓尽致，不管是男主突然改变主意的强行挽留，还是女主的异常的镇定。那份不舍、无奈、悲伤被两个人演绎的堪称完美。神来之笔是最后那对完全男女主复刻版的男女生出现，像回忆一般摆在男女主面前，终于打破了他们的心理防线，最终在痛苦中放开了彼此。</p>
<p><img src="/2021/09/15/movie-loveLikeFlower/6402.jpg" alt="3"></p>
<blockquote>
<p>“合拍”的细节</p>
</blockquote>
<p>电影一开始用大量细节渲染男女主之间的合拍，读同样的书，喜欢同样的作家，看同样的漫画，穿同样的鞋，背同样的包，甚至是几乎情侣的着装，就差把“情侣”二字印在男女主脸上了，但就在男主表白后，两个人就再也没有出现过情侣衫这样的搭配，甚至在后期也显示的用鞋子的不同表现了男女主间的裂缝，这种突然转变我觉得不是所谓剧情需要，而是一种表现手法，所表现的就是男女主一开始可能只是看着合拍罢了，最后两个人在摩天轮也说出了一些细节，比如其实觉得“燃气罐”的视频很无聊，对于木乃伊展也不是真的喜欢等等，两个人一开始只是互相看对眼了而已，至于那些所谓的合拍，只是两个人陷入爱情的表现。这么解读也许有些偏激，但现实的爱情确实很像这般，两个人都深陷而不自知，变得和对方越来越像，但真正的自己不会改变，当走出爱情的泥潭时，一切就变得清晰起来了。</p>
<blockquote>
<p>关于我</p>
</blockquote>
<p>在看电影时，我确实代入了自己很多经历到电影中，于是和男女主产生了共情，也许是我的自作多情，我确实从男女主的恋爱中看到了自己的影子，刚在一起时的开心，中间的争吵，最后的分开以及那份悲伤，我也实实在在的体会过，电影让我更好的审视过去的感情，让我更加理解女生在感情中的体验，这就是我看完后心里久久不能平静的原因。对于爱情，我直到现在也是一位理想主义者，虽然总会被现实打败，但我还是希望能再有一段值得“结束”的开始，但我想这会更难吧。不管怎么说，既然是一场聚会，那我就尽量让聚会欢乐一些吧！</p>
<hr>
<p>最后的一些乱笔，坂田浩二怎么可以把爱情拿捏的这么稳，可以再读一读他的其他书，还有苏打的演技再次震惊我，日本top3我觉得应该有了，以及有村佳纯剧中的样子应该是我的理想型了哈哈哈。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
